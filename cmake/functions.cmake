define_property(
  TARGET
  PROPERTY GENERATED_SOURCE_FILE
  BRIEF_DOCS "Path of the source file generated by a code-generation target.")

# Set the `PYTHON_COMMAND_ENV_VARIABLES` variable with environment variables
# that can be be passed to `cmake -E env` when running python scripts. This
# places both the python library, and pywrenfold (pybind11 wrapper) on the
# PYTHONPATH. Ideally we would get these paths from the targets themselves, but
# the order in which targets are added makes that tricky.
function(set_python_env_variables)
  set(COMPONENTS_BINARY_DIR "${CMAKE_BINARY_DIR}/components")
  set(COMPONENTS_SOURCE_DIR "${CMAKE_SOURCE_DIR}/components")
  # Configure an environment variable for python scripts that depend on the
  # wrenfold python library + wrapper.
  if(WIN32)
    set(PATH_SEP "\;")
  else()
    set(PATH_SEP ":")
  endif()
  set(PYTHON_COMMAND_ENV_VARIABLES
      "PYTHONPATH=${COMPONENTS_BINARY_DIR}/wrapper${PATH_SEP}${COMPONENTS_SOURCE_DIR}/python"
      PARENT_SCOPE)
endfunction()

# Define a code-generator written in C++ with target name `NAME`.
# OUTPUT_FILE_NAME: Name of the output file to put in the build directory.
# SOURCE_FILES: List of C++ files used to build the generator.
function(add_compiled_code_generator NAME)
  set(options "")
  set(oneValueArgs OUTPUT_FILE_NAME)
  set(multiValueArgs SOURCE_FILES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  set(generate_target ${NAME})
  if(${ARGS_OUTPUT_FILE_NAME} STREQUAL "")
    message(FATAL_ERROR "Must specify the OUTPUT_FILE_NAME argument.")
  endif()
  set(GENERATOR_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/${NAME}_gen")
  set(GENERATOR_OUTPUT_FILE "${GENERATOR_OUTPUT_DIR}/${ARGS_OUTPUT_FILE_NAME}")

  # Make output directory.
  add_custom_target(
    ${generate_target}_mkdir COMMAND ${CMAKE_COMMAND} -E make_directory
                                     ${GENERATOR_OUTPUT_DIR})

  # Add an executable target with the provided source files.
  add_executable(${generate_target} ${ARGS_SOURCE_FILES})
  target_link_libraries(${generate_target} wf_core wf_runtime wf_test_support)
  target_compile_definitions(
    ${generate_target}
    PRIVATE "-DGENERATOR_OUTPUT_FILE=\"${GENERATOR_OUTPUT_FILE}\"")
  target_compile_options(${generate_target} PRIVATE ${SHARED_WARNING_FLAGS})
  add_dependencies(${generate_target} ${generate_target}_mkdir)

  # Record the output file as a custom property on the target:
  set_target_properties(${generate_target} PROPERTIES GENERATED_SOURCE_FILE
                                                      ${GENERATOR_OUTPUT_FILE})

  # Add a target that runs the generation:
  add_custom_command(
    OUTPUT ${GENERATOR_OUTPUT_FILE}
    COMMAND
      "$<TARGET_FILE_DIR:${generate_target}>/$<TARGET_FILE_NAME:${generate_target}>"
    WORKING_DIRECTORY ${GENERATOR_OUTPUT_DIR}
    COMMENT "Run code-generator: ${NAME}"
    DEPENDS ${generate_target})
  set_source_files_properties(${GENERATOR_OUTPUT_FILE} PROPERTIES GENERATED
                                                                  TRUE)

  # A custom target for running the code-generation. This is so the user can
  # explicitly run this target from the command line.
  add_custom_target(${generate_target}_run DEPENDS ${GENERATOR_OUTPUT_FILE})
endfunction()

# Add a test written in C++. GENERATOR_TARGET: Make this test depend on the
# specified code-generator target. SOURCE_FILES: Source files of the test.
function(add_cpp_test NAME)
  set(options "")
  set(oneValueArgs GENERATOR_TARGET)
  set(multiValueArgs SOURCE_FILES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  set(GENERATOR_OUTPUT "")
  if(NOT ${ARGS_GENERATOR_TARGET} STREQUAL "")
    get_target_property(GENERATOR_OUTPUT ${ARGS_GENERATOR_TARGET}
                        GENERATED_SOURCE_FILE)
    message(
      STATUS "Adding test: ${NAME} (uses generator ${ARGS_GENERATOR_TARGET})")
  else()
    message(STATUS "Adding test: ${NAME}")
  endif()

  # add executable for the test:
  add_executable(${NAME} ${ARGS_SOURCE_FILES} ${GENERATOR_OUTPUT}
                         $<TARGET_OBJECTS:wf_custom_main>)
  if(NOT ${ARGS_GENERATOR_TARGET} STREQUAL "")
    add_dependencies(${NAME} ${ARGS_GENERATOR_TARGET})
  endif()

  # Make sure generated file is on the include path.
  if(NOT ${GENERATOR_OUTPUT} STREQUAL "")
    cmake_path(GET GENERATOR_OUTPUT PARENT_PATH GENERATOR_INCLUDE_DIR)
    target_include_directories(${NAME} PRIVATE ${GENERATOR_INCLUDE_DIR})
  endif()

  target_link_libraries(
    ${NAME}
    wf_core
    wf_runtime
    wf_test_support
    gtest
    eigen
    fmt::fmt-header-only)
  target_compile_options(${NAME} PRIVATE ${SHARED_WARNING_FLAGS})
  if(NOT MSVC)
    target_compile_options(${NAME} PRIVATE -Wno-unused-comparison)
  endif()

  add_test(${NAME} ${NAME})
endfunction()

# Get the python source files of the wf_python target.
function(get_python_library_sources OUTPUT_VARIABLE)
  if(NOT TARGET wf_python)
    message(FATAL_ERROR "Target wf_python does not exist.")
  endif()
  get_target_property(PYTHON_SOURCE_DIR wf_python SOURCE_DIR)
  get_target_property(PYTHON_LIB_SOURCES wf_python SOURCES)
  list(TRANSFORM PYTHON_LIB_SOURCES PREPEND "${PYTHON_SOURCE_DIR}/")
  set(${OUTPUT_VARIABLE}
      ${PYTHON_LIB_SOURCES}
      PARENT_SCOPE)
endfunction()

# Add a code-generator defined in python. OUTPUT_FILE_NAME: Name of the
# generated source file to write. SOURCE_FILES: Additional python files to track
# as dependencies. SCRIPT_ARGUMENTS: Additional args to pass to the python
# script.
function(add_py_code_generator NAME MAIN_SCRIPT_FILE)
  set(options "")
  set(oneValueArgs OUTPUT_FILE_NAME)
  set(multiValueArgs SOURCE_FILES SCRIPT_ARGUMENTS)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  if(NOT DEFINED Python_EXECUTABLE)
    message(FATAL_ERROR "The Python executable could not be located.")
  endif()

  # Add a custom command that runs the generation:
  if(${ARGS_OUTPUT_FILE_NAME} STREQUAL "")
    message(FATAL_ERROR "Must specify the OUTPUT_FILE_NAME argument.")
  endif()
  set(GENERATOR_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/${NAME}_gen")
  set(GENERATOR_OUTPUT_FILE "${GENERATOR_OUTPUT_DIR}/${ARGS_OUTPUT_FILE_NAME}")

  # Create a list of python sources we depend on. This way, touching python code
  # will cause generation to run again.
  get_python_library_sources(PYTHON_LIB_SOURCES)

  add_custom_command(
    OUTPUT ${GENERATOR_OUTPUT_FILE}
    COMMAND
      ${CMAKE_COMMAND} -E env ${PYTHON_COMMAND_ENV_VARIABLES}
      ${Python_EXECUTABLE} -B "${CMAKE_CURRENT_SOURCE_DIR}/${MAIN_SCRIPT_FILE}"
      "${GENERATOR_OUTPUT_FILE}" ${ARGS_SCRIPT_ARGUMENTS}
    WORKING_DIRECTORY ${GENERATOR_OUTPUT_DIR}
    COMMENT "Run python code-generator: ${NAME}"
    DEPENDS wf_core wf_wrapper wf_python ${MAIN_SCRIPT_FILE} ${SOURCE_FILES}
            ${PYTHON_LIB_SOURCES})

  set_source_files_properties(${GENERATOR_OUTPUT_FILE} PROPERTIES GENERATED
                                                                  TRUE)

  # Create a target we can attach the output source file to as a property.
  add_custom_target(${NAME} DEPENDS ${GENERATOR_OUTPUT_FILE})
  set_target_properties(${NAME} PROPERTIES GENERATED_SOURCE_FILE
                                           ${GENERATOR_OUTPUT_FILE})
endfunction()

# Add a build-step for copying generated files to the source tree (for rust
# tests).
function(copy_generated_file)
  set(options "")
  set(oneValueArgs GENERATOR_TARGET DESTINATION_DIR TARGET_GROUP)
  set(multiValueArgs "")
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})
  if(NOT DEFINED ARGS_GENERATOR_TARGET
     OR NOT DEFINED ARGS_DESTINATION_DIR
     OR NOT DEFINED ARGS_TARGET_GROUP)
    message(
      FATAL_ERROR
        "The GENERATOR_TARGET, DESTINATION_DIR, and TARGET_GROUP arguments are required."
    )
  endif()

  # Get the generated file:
  get_target_property(GENERATOR_OUTPUT ${ARGS_GENERATOR_TARGET}
                      GENERATED_SOURCE_FILE)
  get_filename_component(GENERATED_FILE_NAME ${GENERATOR_OUTPUT} NAME)

  # Create the path to the destination file:
  set(DESTINATION_FILE_PATH
      "${CMAKE_CURRENT_SOURCE_DIR}/${ARGS_DESTINATION_DIR}/${GENERATED_FILE_NAME}"
  )
  add_custom_target(
    ${ARGS_GENERATOR_TARGET}_copy_generated
    DEPENDS ${ARGS_GENERATOR_TARGET} ${GENERATOR_OUTPUT}
    BYPRODUCTS ${DESTINATION_FILE_PATH}
    COMMAND ${CMAKE_COMMAND} -E copy ${GENERATOR_OUTPUT}
            ${DESTINATION_FILE_PATH}
    COMMENT "Copy generated source file for generator: ${ARGS_GENERATOR_TARGET}"
  )
  add_dependencies(${ARGS_TARGET_GROUP} ${ARGS_GENERATOR_TARGET}_copy_generated)
endfunction()

# Define a new python test.
function(add_python_test PYTHON_SOURCE_FILE)
  get_filename_component(TEST_NAME ${PYTHON_SOURCE_FILE} NAME_WE)

  set(options "")
  set(oneValueArgs "")
  set(multiValueArgs SOURCE_FILES SCRIPT_ARGUMENTS)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  if(NOT DEFINED Python_EXECUTABLE)
    message(FATAL_ERROR "The Python executable could not be located.")
  endif()
  if(NOT DEFINED PYTHON_COMMAND_ENV_VARIABLES)
    message(FATAL_ERROR "PYTHON_COMMAND_ENV_VARIABLES should be defined")
  endif()

  # In order for `PYTHONPATH` to be set correctly, we need to pass the
  # environment variable using the cmake command. No other mechanism I have
  # tried will work here.
  add_test(
    NAME ${TEST_NAME}
    COMMAND
      ${CMAKE_COMMAND} -E env ${PYTHON_COMMAND_ENV_VARIABLES}
      ${Python_EXECUTABLE} -B ${CMAKE_CURRENT_SOURCE_DIR}/${PYTHON_SOURCE_FILE}
      ${ARGS_SCRIPT_ARGUMENTS})
  message(STATUS "Added python test: ${TEST_NAME}")
endfunction()
