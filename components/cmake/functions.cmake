define_property(
  TARGET
  PROPERTY GENERATED_SOURCE_FILE
  BRIEF_DOCS "Path of the source file generated by a code-generation target.")

# Define a code-generator written in C++ with target name `NAME`. Args:
# OUTPUT_FILE_NAME: Name of the output file to put in the build directory.
# SOURCE_FILES: List of C++ files used to build the generator.
function(add_compiled_code_generator NAME)
  set(options "")
  set(oneValueArgs OUTPUT_FILE_NAME)
  set(multiValueArgs SOURCE_FILES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  set(generate_target ${NAME})
  set(GENERATOR_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/${NAME}")
  set(GENERATOR_OUTPUT_FILE "${GENERATOR_OUTPUT_DIR}/${ARGS_OUTPUT_FILE_NAME}")

  # Add an executable target with the provided source files.
  add_executable(${generate_target} ${ARGS_SOURCE_FILES})
  target_link_libraries(${generate_target} wf-core wf-runtime wf-test-support)
  target_compile_definitions(
    ${generate_target}
    PRIVATE "-DGENERATOR_OUTPUT_FILE=${GENERATOR_OUTPUT_FILE}")

  # Record the output file as a custom property on the target:
  set_target_properties(${generate_target} PROPERTIES GENERATED_SOURCE_FILE
                                                      ${GENERATOR_OUTPUT_FILE})

  # Add a target that runs the generation:
  add_custom_command(
    OUTPUT ${GENERATOR_OUTPUT_FILE}
    COMMAND
      "$<TARGET_FILE_DIR:${generate_target}>/$<TARGET_FILE_NAME:${generate_target}>"
    WORKING_DIRECTORY ${GENERATOR_OUTPUT_DIR}
    COMMENT "Run code-generator: ${NAME}"
    DEPENDS ${generate_target})

  # A custom target for running the code-generation. This is so the user can
  # explicitly run this target from the command line.
  add_custom_target(${generate_target}_run DEPENDS ${GENERATOR_OUTPUT_FILE})
endfunction()

# Add a test written in C++. Args: GENERATOR_TARGET: Make this test depend on
# the specified code-generator target. SOURCE_FILES: Source files of the test.
function(add_cpp_test NAME)
  set(options "")
  set(oneValueArgs GENERATOR_TARGET)
  set(multiValueArgs SOURCE_FILES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  set(GENERATOR_OUTPUT "")
  if(NOT ${ARGS_GENERATOR_TARGET} STREQUAL "")
    get_target_property(GENERATOR_OUTPUT ${ARGS_GENERATOR_TARGET}
                        GENERATED_SOURCE_FILE)
    message(
      STATUS "Adding test: ${NAME} (uses generator ${ARGS_GENERATOR_TARGET})")
  else()
    message(STATUS "Adding test: ${NAME}")
  endif()

  # add executable for the test:
  add_executable(${NAME} ${ARGS_SOURCE_FILES} ${GENERATOR_OUTPUT}
                         $<TARGET_OBJECTS:wf-custom-main>)

  # Make sure generated file is on the include path.
  if(NOT ${GENERATOR_OUTPUT} STREQUAL "")
    cmake_path(GET GENERATOR_OUTPUT PARENT_PATH GENERATOR_INCLUDE_DIR)
    target_include_directories(${NAME} PRIVATE ${GENERATOR_INCLUDE_DIR})
  endif()

  target_link_libraries(
    ${NAME}
    wf-core
    wf-runtime
    wf-test-support
    gtest
    eigen
    fmt::fmt-header-only)
  target_compile_options(${NAME} PRIVATE ${SHARED_WARNING_FLAGS})
  if(NOT MSVC)
    target_compile_options(${NAME} PRIVATE -Wno-unused-comparison)
  endif()

  add_test(${NAME} ${NAME})
endfunction()

# Define a code-generation test. Each test consists of two stages: First the
# `xxx_generate` target generates a header named `generated.h`, and then the
# `xxx_evaluate` target includes the generated code and runs tests.
function(add_code_generation_test NAME)
  set(options "")
  set(oneValueArgs "")
  set(multiValueArgs GENERATOR_SOURCE_FILES EVALUATOR_SOURCE_FILES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  # First create a target that generates the code:
  set(generate_target ${NAME}_generate)
  add_compiled_code_generator(${generate_target} OUTPUT_FILE_NAME "generated.h"
                              SOURCE_FILES ${ARGS_GENERATOR_SOURCE_FILES})

  set(evaluate_target ${NAME}_test)
  add_cpp_test(${evaluate_target} SOURCE_FILES ${ARGS_EVALUATOR_SOURCE_FILES}
               GENERATOR_TARGET ${generate_target})
endfunction()

# Define a code-generation test that performs the code generation step in
# python, then runs a C++ unit test.
function(add_py_code_generation_test NAME GENERATION_SOURCE_FILE
         TEST_SOURCE_FILE)
  # First create a target that generates the code:
  set(generate_target ${NAME}_generate)
  set(TEST_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/${NAME}")
  set(TEST_OUTPUT_PATH "${TEST_OUTPUT_DIR}/generated.h")

  if(WIN32)
    set(PATH_SEP ";")
  else()
    set(PATH_SEP ":")
  endif()

  if(NOT DEFINED Python_EXECUTABLE)
    message(FATAL_ERROR "The Python executable could not be located.")
  endif()

  # Add a target that runs the generation:
  set(PYTHON_SOURCE_FILE
      "${CMAKE_CURRENT_SOURCE_DIR}/${GENERATION_SOURCE_FILE}")
  add_custom_command(
    OUTPUT ${TEST_OUTPUT_PATH}
    COMMAND
      ${CMAKE_COMMAND} -E env
      "PYTHONPATH=${COMPONENTS_BINARY_DIR}/wrapper${PATH_SEP}${COMPONENTS_SOURCE_DIR}/python"
      ${Python_EXECUTABLE} -B ${PYTHON_SOURCE_FILE}
    WORKING_DIRECTORY "${TEST_OUTPUT_DIR}"
    COMMENT "Run python code-generation for test ${NAME}"
    DEPENDS wf-core wf_wrapper ${PYTHON_SOURCE_FILE})

  add_custom_target(${generate_target} DEPENDS ${TEST_OUTPUT_PATH})

  # Then create a target that evaluates the result:
  set(evaluate_target ${NAME}_test)
  add_executable(
    ${evaluate_target} ${TEST_SOURCE_FILE} $<TARGET_OBJECTS:wf-custom-main>
                       ${TEST_OUTPUT_PATH})
  target_link_libraries(${evaluate_target} wf-runtime wf-test-support eigen
                        gtest)
  target_include_directories(${evaluate_target} PRIVATE ${TEST_OUTPUT_DIR})

  # The evaluation target must depend on running the code-generation
  add_dependencies(${evaluate_target} ${generate_target})

  # Create test case from the evaluation target:
  add_test(${evaluate_target} ${evaluate_target})
endfunction()

# Define a new python test.
function(add_python_test PYTHON_SOURCE_FILE)
  get_filename_component(TEST_NAME ${PYTHON_SOURCE_FILE} NAME_WE)
  if(WIN32)
    set(PATH_SEP ";")
  else()
    set(PATH_SEP ":")
  endif()

  if(NOT DEFINED Python_EXECUTABLE)
    message(FATAL_ERROR "The Python executable could not be located.")
  endif()

  # In order for `PYTHONPATH` to be set correctly, we need to pass the
  # environment variable using the cmake command. No other mechanism I have
  # tried will work here.
  add_test(
    NAME ${TEST_NAME}
    COMMAND
      ${CMAKE_COMMAND} -E env
      "PYTHONPATH=${COMPONENTS_BINARY_DIR}/wrapper${PATH_SEP}${COMPONENTS_SOURCE_DIR}/python"
      ${Python_EXECUTABLE} -B ${CMAKE_CURRENT_SOURCE_DIR}/${PYTHON_SOURCE_FILE})
  message(STATUS "Added python test: ${TEST_NAME}")
endfunction()

function(add_rust_test)
  set(options "")
  set(oneValueArgs NAME CRATE_NAME CODE_GENERATION_FILE)
  set(multiValueArgs CRATE_SOURCES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  if(NOT DEFINED CARGO_PATH)
    message(FATAL_ERROR "Failed to find cargo.")
  endif()

  set(CRATE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/${ARGS_CRATE_NAME}")

  # Add a target to do the cargo build:
  set(CARGO_ENV_VARIABLES
      "CODE_GENERATION_FILE=${ARGS_CODE_GENERATION_FILE}" "CARGO_CMD=test"
      "CARGO_TARGET_DIR=${CMAKE_CURRENT_BINARY_DIR}/target")

  set(CARGO_ARGS --color always)
  if("${CMAKE_BUILD_TYPE}" STREQUAL "Release" OR "${CMAKE_BUILD_TYPE}" STREQUAL
                                                 "RelWithDebInfo")
    list(APPEND CARGO_ARGS --release)
  endif()

  add_custom_target(
    ${ARGS_NAME}_build ALL
    COMMAND ${CMAKE_COMMAND} -E env ${CARGO_ENV_VARIABLES} ${CARGO_PATH} test
            ${CARGO_ARGS} --no-run
    WORKING_DIRECTORY ${CRATE_ROOT}
    COMMENT "Cargo build for test ${ARGS_NAME}"
    DEPENDS ${ARGS_CODE_GENERATION_FILE} ${ARGS_CRATE_SOURCES}
            "${CRATE_ROOT}/Cargo.toml")

  # Add a target to run the test
  add_test(
    NAME ${ARGS_NAME}
    COMMAND ${CMAKE_COMMAND} -E env ${CARGO_ENV_VARIABLES} ${CARGO_PATH} test
            ${CARGO_ARGS}
    WORKING_DIRECTORY ${CRATE_ROOT})
endfunction()

# Function to define a test that generates in C++ and then runs Rust tests.
function(add_rust_generation_test)
  set(options "")
  set(oneValueArgs NAME CRATE_NAME)
  set(multiValueArgs CRATE_SOURCES GENERATOR_SOURCE_FILES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}"
                        ${ARGN})

  # First create a target that generates the code:
  set(generate_target "${ARGS_NAME}_generate")
  set(TEST_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/${ARGS_NAME}")

  add_executable(${generate_target} ${ARGS_GENERATOR_SOURCE_FILES})
  target_link_libraries(${generate_target} wf-core wf-test-support)
  target_compile_options(${generate_target} PRIVATE ${SHARED_WARNING_FLAGS})

  # Add a target that runs the generation:
  add_custom_command(
    OUTPUT "${TEST_OUTPUT_DIR}/generated.rs"
    COMMAND
      "$<TARGET_FILE_DIR:${generate_target}>/$<TARGET_FILE_NAME:${generate_target}>"
    WORKING_DIRECTORY ${TEST_OUTPUT_DIR}
    COMMENT "Run code-generation for test ${ARGS_NAME}"
    DEPENDS ${generate_target})

  add_rust_test(
    NAME
    ${ARGS_NAME}_test
    CRATE_NAME
    ${ARGS_CRATE_NAME}
    CODE_GENERATION_FILE
    "${TEST_OUTPUT_DIR}/generated.rs"
    CRATE_SOURCES
    ${ARGS_CRATE_SOURCES})
endfunction()
