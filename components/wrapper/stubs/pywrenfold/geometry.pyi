import numpy
import pywrenfold.sym
from typing import Any, Iterable, overload

class Quaternion:
    def __init__(self, w: pywrenfold.sym.Expr, x: pywrenfold.sym.Expr, y: pywrenfold.sym.Expr, z: pywrenfold.sym.Expr) -> None: ...
    def conjugate(self) -> Quaternion: ...
    @overload
    def eval(self) -> numpy.ndarray: ...
    @overload
    def eval(self) -> Any: ...
    @staticmethod
    def from_angle_axis(angle: pywrenfold.sym.Expr, vx: pywrenfold.sym.Expr, vy: pywrenfold.sym.Expr, vz: pywrenfold.sym.Expr) -> Quaternion: ...
    @staticmethod
    def from_rotation_matrix(R: pywrenfold.sym.MatrixExpr) -> Quaternion: ...
    @staticmethod
    def from_rotation_vector(x: pywrenfold.sym.Expr, y: pywrenfold.sym.Expr, z: pywrenfold.sym.Expr, epsilon: pywrenfold.sym.Expr | None) -> Quaternion: ...
    @overload
    @staticmethod
    def from_wxyz(wxyz: pywrenfold.sym.MatrixExpr) -> Quaternion: ...
    @overload
    @staticmethod
    def from_wxyz(wxyz: Iterable) -> Quaternion: ...
    @staticmethod
    def from_x_angle(angle: pywrenfold.sym.Expr) -> Quaternion: ...
    @overload
    @staticmethod
    def from_xyzw(xyzw: pywrenfold.sym.MatrixExpr) -> Quaternion: ...
    @overload
    @staticmethod
    def from_xyzw(xyzw: Iterable) -> Quaternion: ...
    @staticmethod
    def from_y_angle(angle: pywrenfold.sym.Expr) -> Quaternion: ...
    @staticmethod
    def from_z_angle(angle: pywrenfold.sym.Expr) -> Quaternion: ...
    def inverse(self) -> Quaternion: ...
    @overload
    def is_identical_to(self, other: Quaternion) -> bool: ...
    @overload
    def is_identical_to(self, other: Quaternion) -> bool: ...
    @overload
    def norm(self) -> pywrenfold.sym.Expr: ...
    @overload
    def norm(self) -> Any: ...
    @overload
    def normalized(self) -> Quaternion: ...
    @overload
    def normalized(self) -> Any: ...
    @overload
    def normalized(self) -> Any: ...
    def right_local_coordinates_derivative(self) -> pywrenfold.sym.MatrixExpr: ...
    def right_retract_derivative(self) -> pywrenfold.sym.MatrixExpr: ...
    @overload
    def squared_norm(self) -> pywrenfold.sym.Expr: ...
    @overload
    def squared_norm(self) -> Any: ...
    def subs(self, target: pywrenfold.sym.Expr, replacement: pywrenfold.sym.Expr) -> Quaternion: ...
    def to_angle_axis(self, epsilon: pywrenfold.sym.Expr | None = ...) -> tuple[pywrenfold.sym.Expr, pywrenfold.sym.MatrixExpr]: ...
    def to_list(self) -> list: ...
    @overload
    def to_rotation_matrix(self) -> pywrenfold.sym.MatrixExpr: ...
    @overload
    def to_rotation_matrix(self) -> Any: ...
    @overload
    def to_rotation_matrix(self) -> Any: ...
    def to_rotation_vector(self, epsilon: pywrenfold.sym.Expr | None = ..., use_atan2: bool = ...) -> pywrenfold.sym.MatrixExpr: ...
    def to_vector_wxyz(self) -> pywrenfold.sym.MatrixExpr: ...
    def to_vector_xyzw(self) -> pywrenfold.sym.MatrixExpr: ...
    @staticmethod
    def with_name(name: str) -> Quaternion: ...
    def __eq__(self, other: Quaternion) -> bool: ...
    def __hash__(self) -> int: ...
    def __mul__(self, arg0: Quaternion) -> Quaternion: ...
    @property
    def w(self) -> pywrenfold.sym.Expr: ...
    @property
    def x(self) -> pywrenfold.sym.Expr: ...
    @property
    def y(self) -> pywrenfold.sym.Expr: ...
    @property
    def z(self) -> pywrenfold.sym.Expr: ...

def inverse_left_jacobian_of_so3(w: pywrenfold.sym.MatrixExpr, epsilon: pywrenfold.sym.Expr | None) -> pywrenfold.sym.MatrixExpr: ...
def left_jacobian_of_so3(w: pywrenfold.sym.MatrixExpr, epsilon: pywrenfold.sym.Expr | None) -> pywrenfold.sym.MatrixExpr: ...
