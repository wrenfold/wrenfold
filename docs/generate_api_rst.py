"""
Script that generates the `python_api_docs.rst` file.
"""

import argparse
import inspect
import typing as T
from pathlib import Path

# The built library needs to be on the import path by this point.
from wrenfold import (
    ast,
    code_generation,
    enumerations,
    exceptions,
    expressions,
    external_functions,
    geometry,
    sym,
    sympy_conversion,
    type_annotations,
    type_info,
)

DOCS_DIR = Path(__file__).parent.absolute()


def generate_rst_for_module(module: T.Any, module_name: str, output_dir: Path):
    """
    Write out rst files for classes + functions in the provided module.
    """
    functions = []
    classes = []
    data = []
    for member_name in sorted(dir(module)):
        if member_name.startswith("_"):
            continue

        member = getattr(module, member_name)
        if inspect.ismodule(member):
            continue
        if member.__doc__ is not None and "OMIT_FROM_SPHINX" in member.__doc__:
            continue

        if inspect.isclass(member):
            class_static_functions = []
            for child_member_name in sorted(dir(member)):
                child_member = getattr(member, child_member_name)
                if "nanobind.nb_func" in str(child_member):
                    class_static_functions.append(child_member_name)

            classes.append((member_name, class_static_functions))

        elif inspect.isbuiltin(member) or inspect.isfunction(member) or callable(member):
            functions.append(member_name)
        elif isinstance(member, (sym.Expr, sym.BooleanExpr)):
            data.append(member_name)

    parts = [f"{module_name}\n{'=' * len(module_name)}"]
    parts.extend(f".. autodata:: wrenfold.{module_name}.{d}" for d in data)
    parts.extend(f".. autofunction:: wrenfold.{module_name}.{func}" for func in functions)

    # Based on: https://github.com/wjakob/nanobind/discussions/707
    for klass, class_static_functions in classes:
        excluded_members = ["__dict__", "__weakref__", "__repr__", "__getstate__", "__setstate__"]
        excluded_members += class_static_functions
        class_directives = "\n  ".join(
            [
                ":members:",
                ":special-members:",
                f":exclude-members: {','.join(excluded_members)}",
            ]
        )
        directive = f".. autoclass:: wrenfold.{module_name}.{klass}\n  {class_directives}"
        for func_name in class_static_functions:
            directive += f"\n\n  .. automethod:: {func_name}"
        parts.append(directive)

    contents = f".. Machine generated by {Path(__file__).name}. Do not edit by hand.\n\n"
    contents += "\n\n".join(parts)
    contents += "\n"

    output_path = output_dir / f"{module_name}.rst"
    with open(output_path, "wb") as handle:
        handle.write(contents.encode("utf-8"))


def main(args: argparse.Namespace):
    output_dir = Path(args.output_dir)
    generate_rst_for_module(module=sym, module_name="sym", output_dir=output_dir)
    generate_rst_for_module(module=geometry, module_name="geometry", output_dir=output_dir)
    generate_rst_for_module(module=ast, module_name="ast", output_dir=output_dir)
    generate_rst_for_module(
        module=code_generation, module_name="code_generation", output_dir=output_dir
    )
    generate_rst_for_module(
        module=sympy_conversion, module_name="sympy_conversion", output_dir=output_dir
    )
    generate_rst_for_module(
        module=type_annotations, module_name="type_annotations", output_dir=output_dir
    )
    generate_rst_for_module(module=enumerations, module_name="enumerations", output_dir=output_dir)
    generate_rst_for_module(module=exceptions, module_name="exceptions", output_dir=output_dir)
    generate_rst_for_module(module=expressions, module_name="expressions", output_dir=output_dir)
    generate_rst_for_module(module=type_info, module_name="type_info", output_dir=output_dir)
    generate_rst_for_module(
        module=external_functions,
        module_name="external_functions",
        output_dir=output_dir,
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--output_dir",
        type=str,
        help="Output directory write the RST file into.",
        default=str(DOCS_DIR / "source" / "python_api"),
    )
    return parser.parse_args()


if __name__ == "__main__":
    main(parse_args())
